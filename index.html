<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piet„Ç®„Éá„Ç£„Çø</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: #252526;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #3e3e42;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .btn-run {
            background: #0e639c;
            color: white;
        }
        .btn-run:hover {
            background: #1177bb;
        }
        .btn-step {
            background: #0aa;
            color: white;
        }
        .btn-step:hover {
            background: #0cc;
        }
        .btn-reset {
            background: #c93;
            color: white;
        }
        .btn-reset:hover {
            background: #da4;
        }
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .color-palette {
            background: #252526;
            padding: 20px;
            width: 220px;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }
        .palette-title {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ccc;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0;
            margin-bottom: 0;
        }
        .color-grid-special {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0;
            margin-bottom: 10px;
        }
        .color-btn {
            width: 100%;
            height: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff;
        }
        .color-btn:hover {
            opacity: 0.8;
        }
        .color-btn.selected {
            box-shadow: 0 0 0 3px #fff inset;
        }
        .color-btn .command-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 9px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 2px #fff, 0 0 2px #fff;
            pointer-events: none;
            white-space: nowrap;
        }
        .eyedropper-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .eyedropper-btn:hover {
            background: #555;
        }
        .eyedropper-btn.active {
            background: #0aa;
            border-color: #0ff;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }
        .grid-controls {
            position: absolute;
        }
        .grid-controls.top {
            top: 50%;
            transform: translateY(-50%);
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .grid-controls.bottom {
            top: 50%;
            transform: translateY(-50%);
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .grid-controls.left {
            left: 50%;
            transform: translateX(-50%);
            top: 20px;
            display: flex;
            gap: 5px;
        }
        .grid-controls.right {
            left: 50%;
            transform: translateX(-50%);
            bottom: 20px;
            display: flex;
            gap: 5px;
        }
        .grid-btn {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .grid-btn:hover {
            background: #555;
        }
        canvas {
            border: 2px solid #3e3e42;
            background: white;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .bottom-panel {
            background: #252526;
            border-top: 1px solid #3e3e42;
            height: 200px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-tabs {
            display: flex;
            background: #1e1e1e;
            border-bottom: 1px solid #3e3e42;
        }
        .panel-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            font-size: 12px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .panel-tab:hover {
            color: #fff;
        }
        .panel-tab.active {
            color: #fff;
            border-bottom-color: #0e639c;
        }
        .panel-content-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .panel-section {
            flex: 1;
            padding: 15px;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .panel-section:last-child {
            border-right: none;
        }
        .variables-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 10px;
        }
        .variable-item {
            flex: 1;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 4px;
        }
        .variable-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .btn-download {
            background: #444;
            color: white;
            margin-left: auto;
        }
        .btn-download:hover {
            background: #555;
        }
        .panel-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        .panel-content {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #ddd;
            white-space: pre-wrap;
        }
        .stdin-input {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            color: #ddd;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            padding: 10px;
            resize: none;
        }
        .stdin-input:focus {
            outline: none;
            border-color: #0e639c;
        }
        .log-section {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        .log-item {
            padding: 5px 10px;
            margin-bottom: 2px;
            background: #1e1e1e;
            border-left: 3px solid #0e639c;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-item.command {
            border-left-color: #0aa;
        }
        .log-item.move {
            border-left-color: #c93;
        }
        .log-item.rotate {
            border-left-color: #da4;
        }
        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="btn btn-run" onclick="run()">‚ñ∂ ÂÆüË°å</button>
        <button class="btn btn-step" onclick="step()">‚èØ „Çπ„ÉÜ„ÉÉ„ÉóÂÆüË°å</button>
        <button class="btn btn-reset" onclick="resetExecution()">üîÑ ÂÆüË°å„É™„Çª„ÉÉ„Éà</button>
        <span style="margin-left: 20px; color: #888;">Grid: <span id="gridSize">10√ó10</span></span>
        <button class="btn btn-download" onclick="copyPPM()">üìã PPM„Ç≥„Éî„Éº</button>
    </div>

    <div class="main-container">
        <div class="color-palette">
            <div class="palette-title">„Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà</div>
            <div class="color-grid" id="colorPalette"></div>
            <div class="color-grid-special" id="colorPaletteSpecial"></div>
            <button class="eyedropper-btn" id="eyedropperBtn" onclick="toggleEyedropper()">
                üé® „Çπ„Éù„Ç§„Éà
            </button>
        </div>

        <div class="canvas-container">
            <div class="grid-controls top">
                <button class="grid-btn" onclick="addRow('top')">+ Ë°å</button>
                <button class="grid-btn" onclick="removeRow('top')">- Ë°å</button>
            </div>
            <div class="grid-controls left">
                <button class="grid-btn" onclick="addColumn('left')">+ Âàó</button>
                <button class="grid-btn" onclick="removeColumn('left')">- Âàó</button>
            </div>
            
            <canvas id="canvas"></canvas>
            
            <div class="grid-controls right">
                <button class="grid-btn" onclick="addColumn('right')">+ Âàó</button>
                <button class="grid-btn" onclick="removeColumn('right')">- Âàó</button>
            </div>
            <div class="grid-controls bottom">
                <button class="grid-btn" onclick="addRow('bottom')">+ Ë°å</button>
                <button class="grid-btn" onclick="removeRow('bottom')">- Ë°å</button>
            </div>
        </div>
    </div>

    <div class="bottom-panel">
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="switchTab(0)">ÂÖ•Âá∫Âäõ„Éª„Çπ„Çø„ÉÉ„ÇØ</button>
            <button class="panel-tab" onclick="switchTab(1)">ÂÆüË°å„É≠„Ç∞</button>
        </div>
        <div class="panel-content-container" id="panelContainer">
            <!-- Tab 0: IO and Stack -->
            <div class="panel-view" id="panel0" style="display: flex; flex: 1;">
                <div class="panel-section">
                    <div class="panel-title">Ê®ôÊ∫ñÂÖ•Âäõ</div>
                    <textarea class="stdin-input" id="stdin" placeholder="ÂÖ•Âäõ„Éá„Éº„Çø„ÇíÂÖ•Âäõ..."></textarea>
                </div>
                <div class="panel-section">
                    <div class="panel-title">Ê®ôÊ∫ñÂá∫Âäõ</div>
                    <div class="panel-content" id="stdout">-</div>
                </div>
                <div class="panel-section">
                    <div class="panel-title">„Çπ„Çø„ÉÉ„ÇØ</div>
                    <div class="panel-content" id="stack">[]</div>
                </div>
                <div class="panel-section">
                    <div class="panel-title">Â§âÊï∞</div>
                    <div class="variables-container">
                        <div class="variable-item">
                            <div class="variable-label">DP</div>
                            <div class="panel-content" id="dp">right (0)</div>
                        </div>
                        <div class="variable-item">
                            <div class="variable-label">CC</div>
                            <div class="panel-content" id="cc">left (0)</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 1: Execution Log -->
            <div class="panel-view" id="panel1" style="display: none; flex: 1; flex-direction: column;">
                <div class="log-section">
                    <div class="log-controls">
                        <label class="checkbox-label">
                            <input type="checkbox" id="logEnabled" checked onchange="toggleLog()">
                            „É≠„Ç∞„ÇíË®òÈå≤
                        </label>
                        <button class="btn" onclick="clearLog()" style="padding: 4px 8px; font-size: 11px;">„ÇØ„É™„Ç¢</button>
                    </div>
                    <div id="logContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const PIET_COLORS = [
            // Light hues (row 1)
            { name: 'light red', color: '#FFC0C0' },
            { name: 'light yellow', color: '#FFFFC0' },
            { name: 'light green', color: '#C0FFC0' },
            { name: 'light cyan', color: '#C0FFFF' },
            { name: 'light blue', color: '#C0C0FF' },
            { name: 'light magenta', color: '#FFC0FF' },
            // Normal hues (row 2)
            { name: 'red', color: '#FF0000' },
            { name: 'yellow', color: '#FFFF00' },
            { name: 'green', color: '#00FF00' },
            { name: 'cyan', color: '#00FFFF' },
            { name: 'blue', color: '#0000FF' },
            { name: 'magenta', color: '#FF00FF' },
            // Dark hues (row 3)
            { name: 'dark red', color: '#C00000' },
            { name: 'dark yellow', color: '#C0C000' },
            { name: 'dark green', color: '#00C000' },
            { name: 'dark cyan', color: '#00C0C0' },
            { name: 'dark blue', color: '#0000C0' },
            { name: 'dark magenta', color: '#C000C0' },
            // Special
            { name: 'white', color: '#FFFFFF' },
            { name: 'black', color: '#000000' }
        ];

        let gridWidth = 10;
        let gridHeight = 10;
        let cellSize = 30;
        let grid = [];
        let selectedColor = '#FFFFFF';
        let selectedColorIndex = 18; // white
        let currentCell = null;
        let eyedropperMode = false;
        let isRunning = false;
        let isStepMode = false;

        // Interpreter state
        let stack = [];
        let dp = 0; // 0=right, 1=down, 2=left, 3=up
        let cc = 0; // 0=left, 1=right
        let currentPos = null;
        let previousBlockSize = 0;
        let stepCount = 0;
        let outputBuffer = '';
        let attemptCount = 0;
        let whiteLoopDetector = new Set();

        // Log
        let executionLog = [];
        let logEnabled = true;

        // Piet commands based on hue change and lightness change
        const PIET_COMMANDS = [
            ['‚Äî', 'push', 'pop'],
            ['add', 'sub', 'mul'],
            ['div', 'mod', 'not'],
            ['gtr', 'ptr', 'swi'],
            ['dup', 'roll', 'inn'],
            ['inc', 'out', 'ouc']
        ];

        const DP_NAMES = ['right', 'down', 'left', 'up'];
        const CC_NAMES = ['left', 'right'];

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function switchTab(index) {
            const tabs = document.querySelectorAll('.panel-tab');
            const panels = document.querySelectorAll('.panel-view');
            
            tabs.forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            panels.forEach((panel, i) => {
                panel.style.display = i === index ? 'flex' : 'none';
            });
        }

        function addLog(message, type = 'info') {
            if (!logEnabled) return;
            
            executionLog.push({ message, type, timestamp: Date.now() });
            
            const logContent = document.getElementById('logContent');
            const logItem = document.createElement('div');
            logItem.className = `log-item ${type}`;
            logItem.textContent = message;
            logContent.appendChild(logItem);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function clearLog() {
            executionLog = [];
            document.getElementById('logContent').innerHTML = '';
        }

        function toggleLog() {
            logEnabled = document.getElementById('logEnabled').checked;
        }

        function initGrid() {
            grid = [];
            for (let y = 0; y < gridHeight; y++) {
                grid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    grid[y][x] = '#FFFFFF';
                }
            }
            updateCanvas();
        }

        function updateCanvas() {
            canvas.width = gridWidth * cellSize;
            canvas.height = gridHeight * cellSize;
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    ctx.fillStyle = grid[y][x];
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            if (currentCell) {
                const [cx, cy] = currentCell;
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 3;
                ctx.strokeRect(cx * cellSize, cy * cellSize, cellSize, cellSize);
            }

            document.getElementById('gridSize').textContent = `${gridWidth}√ó${gridHeight}`;
        }

        function updateDebugDisplay() {
            document.getElementById('stack').textContent = JSON.stringify(stack);
            document.getElementById('dp').textContent = `${DP_NAMES[dp]} (${dp})`;
            document.getElementById('cc').textContent = `${CC_NAMES[cc]} (${cc})`;
            document.getElementById('stdout').textContent = outputBuffer || '-';
        }

        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            const paletteSpecial = document.getElementById('colorPaletteSpecial');
            
            const colorOrder = [
                0, 6, 12,
                1, 7, 13,
                2, 8, 14,
                3, 9, 15,
                4, 10, 16,
                5, 11, 17
            ];
            
            colorOrder.forEach(i => {
                const c = PIET_COLORS[i];
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.style.background = c.color;
                btn.title = c.name;
                btn.onclick = () => selectColor(c.color, btn);
                palette.appendChild(btn);
            });
            
            for (let i = 18; i < 20; i++) {
                const c = PIET_COLORS[i];
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.style.background = c.color;
                btn.title = c.name;
                btn.onclick = () => selectColor(c.color, btn);
                if (i === 18) {
                    btn.classList.add('selected');
                }
                paletteSpecial.appendChild(btn);
            }
            
            updateCommandDisplay();
        }

        function selectColor(color, btn) {
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            selectedColor = color;
            
            for (let i = 0; i < PIET_COLORS.length; i++) {
                if (PIET_COLORS[i].color === color) {
                    selectedColorIndex = i;
                    break;
                }
            }
            
            eyedropperMode = false;
            document.getElementById('eyedropperBtn').classList.remove('active');
            updateCommandDisplay();
        }

        function updateCommandDisplay() {
            const colorBtns = document.querySelectorAll('#colorPalette .color-btn');
            
            colorBtns.forEach(btn => {
                const existingText = btn.querySelector('.command-text');
                if (existingText) {
                    existingText.remove();
                }
            });
            
            if (selectedColorIndex >= 18) {
                return;
            }
            
            const selectedHue = selectedColorIndex % 6;
            const selectedLightness = Math.floor(selectedColorIndex / 6);
            
            const colorOrder = [
                0, 6, 12,
                1, 7, 13,
                2, 8, 14,
                3, 9, 15,
                4, 10, 16,
                5, 11, 17
            ];
            
            colorOrder.forEach((colorIdx, btnIdx) => {
                const targetHue = colorIdx % 6;
                const targetLightness = Math.floor(colorIdx / 6);
                
                const hueChange = (targetHue - selectedHue + 6) % 6;
                const lightnessChange = (targetLightness - selectedLightness + 3) % 3;
                
                const command = PIET_COMMANDS[hueChange][lightnessChange];
                
                const btn = colorBtns[btnIdx];
                const commandText = document.createElement('span');
                commandText.className = 'command-text';
                commandText.textContent = command;
                btn.appendChild(commandText);
            });
        }

        function toggleEyedropper() {
            eyedropperMode = !eyedropperMode;
            const btn = document.getElementById('eyedropperBtn');
            if (eyedropperMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);

            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                if (eyedropperMode) {
                    selectedColor = grid[y][x];
                    const colorBtns = document.querySelectorAll('.color-btn');
                    colorBtns.forEach((btn, i) => {
                        btn.classList.remove('selected');
                        if (PIET_COLORS[i].color === selectedColor) {
                            btn.classList.add('selected');
                            selectedColorIndex = i;
                        }
                    });
                    eyedropperMode = false;
                    document.getElementById('eyedropperBtn').classList.remove('active');
                    updateCommandDisplay();
                } else {
                    grid[y][x] = selectedColor;
                    updateCanvas();
                }
            }
        });

        function addRow(position) {
            const newRow = new Array(gridWidth).fill('#FFFFFF');
            if (position === 'top') {
                grid.unshift(newRow);
            } else {
                grid.push(newRow);
            }
            gridHeight++;
            updateCanvas();
        }

        function removeRow(position) {
            if (gridHeight <= 1) return;
            if (position === 'top') {
                grid.shift();
            } else {
                grid.pop();
            }
            gridHeight--;
            updateCanvas();
        }

        function addColumn(position) {
            for (let y = 0; y < gridHeight; y++) {
                if (position === 'left') {
                    grid[y].unshift('#FFFFFF');
                } else {
                    grid[y].push('#FFFFFF');
                }
            }
            gridWidth++;
            updateCanvas();
        }

        function removeColumn(position) {
            if (gridWidth <= 1) return;
            for (let y = 0; y < gridHeight; y++) {
                if (position === 'left') {
                    grid[y].shift();
                } else {
                    grid[y].pop();
                }
            }
            gridWidth--;
            updateCanvas();
        }

        function run() {
            resetExecution();
            isRunning = true;
            isStepMode = false;
            addLog('ÂÆüË°åÈñãÂßã', 'info');
            runLoop();
        }

        function step() {
            if (!isRunning) {
                resetExecution();
                isRunning = true;
                addLog('„Çπ„ÉÜ„ÉÉ„ÉóÂÆüË°åÈñãÂßã', 'info');
            }
            isStepMode = true;
            executeStep();
        }

        function resetExecution() {
            stack = [];
            dp = 0;
            cc = 0;
            currentPos = [0, 0];
            previousBlockSize = 0;
            stepCount = 0;
            outputBuffer = '';
            currentCell = [0, 0];
            attemptCount = 0;
            whiteLoopDetector = new Set();
            updateCanvas();
            updateDebugDisplay();
            addLog('ÂÆüË°å„É™„Çª„ÉÉ„Éà', 'info');
        }

        function runLoop() {
            if (!isRunning) return;
            
            const result = executeStep();
            
            if (result === 'continue') {
                setTimeout(runLoop, 50);
            } else {
                isRunning = false;
                currentCell = null;
                updateCanvas();
                if (result === 'timeout') {
                    alert('ÂÆüË°å„Åå1000000„Çπ„ÉÜ„ÉÉ„Éó„ÇíË∂Ö„Åà„Åü„Åü„ÇÅÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
                    addLog('„Çø„Ç§„É†„Ç¢„Ç¶„Éà', 'info');
                } else {
                    addLog('ÂÆüË°åÁµÇ‰∫Ü', 'info');
                }
            }
        }

        function executeStep() {
            if (stepCount >= 1000000) {
                return 'timeout';
            }
            stepCount++;

            const [x, y] = currentPos;
            const currentColor = grid[y][x];
            
            // White cell loop detection
            if (currentColor === '#FFFFFF') {
                const key = `${x},${y},${dp}`;
                if (whiteLoopDetector.has(key)) {
                    addLog(`ÁôΩ„Éû„Çπ„É´„Éº„ÉóÊ§úÂá∫ at (${x}, ${y})`, 'info');
                    return 'halt';
                }
                whiteLoopDetector.add(key);
            } else {
                whiteLoopDetector = new Set();
            }
            
            // Get edge position for color blocks
            let edgePos;
            if (currentColor !== '#FFFFFF' && currentColor !== '#000000') {
                const currentBlock = getColorBlock(x, y, currentColor);
                edgePos = findEdge(currentBlock, dp, cc);
                previousBlockSize = currentBlock.size;
            } else {
                edgePos = [x, y];
            }
            
            // Try to move
            const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
            const [dx, dy] = directions[dp];
            let [nx, ny] = edgePos;
            nx += dx;
            ny += dy;
            
            // Check if blocked
            const isBlocked = (nx < 0 || nx >= gridWidth || ny < 0 || ny >= gridHeight) ||
                            (grid[ny][nx] === '#000000');
            
            if (isBlocked) {
                // In white cell, only rotate DP
                if (currentColor === '#FFFFFF') {
                    dp = (dp + 1) % 4;
                    attemptCount++;
                    
                    if (attemptCount >= 4) {
                        addLog(`ÁôΩ„Éû„Çπ„ÅßÂÖ®ÊñπÂêë„Éñ„É≠„ÉÉ„ÇØ at (${x}, ${y})`, 'info');
                        return 'halt';
                    }
                    
                    addLog(`ÁôΩ„Éû„Çπ: DPÂõûËª¢ ‚Üí ${DP_NAMES[dp]}`, 'rotate');
                    updateCanvas();
                    updateDebugDisplay();
                    return isStepMode ? 'halt' : 'continue';
                }
                
                // In color block, try CC flip first
                if (attemptCount % 2 === 0) {
                    cc = 1 - cc;
                    attemptCount++;
                    addLog(`„Éñ„É≠„ÉÉ„ÇØ: CCÂèçËª¢ ‚Üí ${CC_NAMES[cc]}`, 'rotate');
                    updateCanvas();
                    updateDebugDisplay();
                    return isStepMode ? 'halt' : 'continue';
                } else {
                    dp = (dp + 1) % 4;
                    attemptCount++;
                    
                    if (attemptCount >= 8) {
                        addLog('ÂÖ®ÊñπÂêë„Éñ„É≠„ÉÉ„ÇØ', 'info');
                        return 'halt';
                    }
                    
                    addLog(`„Éñ„É≠„ÉÉ„ÇØ: DPÂõûËª¢ ‚Üí ${DP_NAMES[dp]}`, 'rotate');
                    updateCanvas();
                    updateDebugDisplay();
                    return isStepMode ? 'halt' : 'continue';
                }
            }
            
            // Not blocked - can move
            attemptCount = 0;
            const nextColor = grid[ny][nx];
            
            // Execute command if transitioning from color to color
            if (currentColor !== '#FFFFFF' && currentColor !== '#000000' &&
                nextColor !== '#FFFFFF' && nextColor !== '#000000') {
                const cmd = getCommand(currentColor, nextColor);
                addLog(`„Ç≥„Éû„É≥„ÉâÂÆüË°å: ${cmd} (${getColorName(currentColor)} ‚Üí ${getColorName(nextColor)})`, 'command');
                executeCommand(currentColor, nextColor);
            }
            
            // Move
            addLog(`ÁßªÂãï: (${x}, ${y}) ‚Üí (${nx}, ${ny}) [${getColorName(currentColor)} ‚Üí ${getColorName(nextColor)}]`, 'move');
            currentPos = [nx, ny];
            currentCell = [nx, ny];
            
            updateCanvas();
            updateDebugDisplay();
            
            return isStepMode ? 'halt' : 'continue';
        }

        function getColorName(color) {
            const c = PIET_COLORS.find(p => p.color === color);
            return c ? c.name : 'unknown';
        }

        function getCommand(fromColor, toColor) {
            const fromIdx = PIET_COLORS.findIndex(c => c.color === fromColor);
            const toIdx = PIET_COLORS.findIndex(c => c.color === toColor);
            
            if (fromIdx < 0 || fromIdx >= 18 || toIdx < 0 || toIdx >= 18) return '‚Äî';
            
            const fromHue = fromIdx % 6;
            const fromLight = Math.floor(fromIdx / 6);
            const toHue = toIdx % 6;
            const toLight = Math.floor(toIdx / 6);
            
            const hueChange = (toHue - fromHue + 6) % 6;
            const lightChange = (toLight - fromLight + 3) % 3;
            
            return PIET_COMMANDS[hueChange][lightChange];
        }

        function getColorBlock(startX, startY, color) {
            const visited = new Set();
            const queue = [[startX, startY]];
            const cells = [];
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) continue;
                if (grid[y][x] !== color) continue;
                
                visited.add(key);
                cells.push([x, y]);
                
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return { cells, size: cells.length };
        }

        function findEdge(block, direction, chooser) {
            const cells = block.cells;
            
            let edgeCells;
            if (direction === 0) {
                const maxX = Math.max(...cells.map(c => c[0]));
                edgeCells = cells.filter(c => c[0] === maxX);
                edgeCells.sort((a, b) => chooser === 0 ? a[1] - b[1] : b[1] - a[1]);
            } else if (direction === 1) {
                const maxY = Math.max(...cells.map(c => c[1]));
                edgeCells = cells.filter(c => c[1] === maxY);
                edgeCells.sort((a, b) => chooser === 0 ? b[0] - a[0] : a[0] - b[0]);
            } else if (direction === 2) {
                const minX = Math.min(...cells.map(c => c[0]));
                edgeCells = cells.filter(c => c[0] === minX);
                edgeCells.sort((a, b) => chooser === 0 ? b[1] - a[1] : a[1] - b[1]);
            } else {
                const minY = Math.min(...cells.map(c => c[1]));
                edgeCells = cells.filter(c => c[1] === minY);
                edgeCells.sort((a, b) => chooser === 0 ? a[0] - b[0] : b[0] - a[0]);
            }
            
            return edgeCells[0];
        }

        function executeCommand(fromColor, toColor) {
            const fromIdx = PIET_COLORS.findIndex(c => c.color === fromColor);
            const toIdx = PIET_COLORS.findIndex(c => c.color === toColor);
            
            if (fromIdx < 0 || fromIdx >= 18 || toIdx < 0 || toIdx >= 18) return;
            
            const fromHue = fromIdx % 6;
            const fromLight = Math.floor(fromIdx / 6);
            const toHue = toIdx % 6;
            const toLight = Math.floor(toIdx / 6);
            
            const hueChange = (toHue - fromHue + 6) % 6;
            const lightChange = (toLight - fromLight + 3) % 3;
            
            const command = PIET_COMMANDS[hueChange][lightChange];
            
            executeCommandByName(command);
        }

        function executeCommandByName(cmd) {
            const inputText = document.getElementById('stdin').value;
            
            switch(cmd) {
                case '‚Äî': break;
                case 'push':
                    stack.push(previousBlockSize);
                    break;
                case 'pop':
                    if (stack.length > 0) stack.pop();
                    break;
                case 'add':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a + b);
                    }
                    break;
                case 'sub':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a - b);
                    }
                    break;
                case 'mul':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a * b);
                    }
                    break;
                case 'div':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        if (b !== 0) stack.push(Math.floor(a / b));
                        else stack.push(0);
                    }
                    break;
                case 'mod':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        if (b !== 0) stack.push(a % b);
                        else stack.push(0);
                    }
                    break;
                case 'not':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        stack.push(a === 0 ? 1 : 0);
                    }
                    break;
                case 'gtr':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a > b ? 1 : 0);
                    }
                    break;
                case 'ptr':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        dp = ((dp + a) % 4 + 4) % 4;
                    }
                    break;
                case 'swi':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        if (Math.abs(a) % 2 === 1) {
                            cc = 1 - cc;
                        }
                    }
                    break;
                case 'dup':
                    if (stack.length >= 1) {
                        const a = stack[stack.length - 1];
                        stack.push(a);
                    }
                    break;
                case 'roll':
                    if (stack.length >= 2) {
                        const rolls = stack.pop();
                        const depth = stack.pop();
                        if (depth > 0 && depth <= stack.length) {
                            const top = stack.splice(stack.length - depth);
                            const normalizedRolls = ((rolls % depth) + depth) % depth;
                            for (let i = 0; i < normalizedRolls; i++) {
                                top.unshift(top.pop());
                            }
                            stack.push(...top);
                        }
                    }
                    break;
                case 'inn':
                    const num = parseInt(inputText);
                    if (!isNaN(num)) {
                        stack.push(num);
                    }
                    break;
                case 'inc':
                    if (inputText.length > 0) {
                        stack.push(inputText.charCodeAt(0));
                    }
                    break;
                case 'out':
                    if (stack.length >= 1) {
                        const val = stack.pop();
                        outputBuffer += val;
                    }
                    break;
                case 'ouc':
                    if (stack.length >= 1) {
                        const val = stack.pop();
                        outputBuffer += String.fromCharCode(val);
                    }
                    break;
            }
        }

        function copyPPM() {
            let ppm = `P3\n${gridWidth} ${gridHeight}\n255\n`;
            
            for (let y = 0; y < gridHeight; y++) {
                const row = [];
                for (let x = 0; x < gridWidth; x++) {
                    const color = grid[y][x];
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    row.push(`${r} ${g} ${b}`);
                }
                ppm += row.join(' ') + '\n';
            }
            
            navigator.clipboard.writeText(ppm).then(() => {
                alert('PPMÂΩ¢Âºè„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
            }).catch(err => {
                alert('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err);
            });
        }

        initColorPalette();
        initGrid();
    </script>
</body>
</html>