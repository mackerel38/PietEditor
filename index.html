<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piet„Ç®„Éá„Ç£„Çø</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: #252526;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #3e3e42;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .btn-run {
            background: #0e639c;
            color: white;
        }
        .btn-run:hover {
            background: #1177bb;
        }
        .btn-step {
            background: #0aa;
            color: white;
        }
        .btn-step:hover {
            background: #0cc;
        }
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .color-palette {
            background: #252526;
            padding: 20px;
            width: 220px;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }
        .palette-title {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ccc;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0;
            margin-bottom: 0;
        }
        .color-grid-special {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0;
            margin-bottom: 10px;
        }
        .color-btn {
            width: 100%;
            height: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff;
        }
        .color-btn:hover {
            opacity: 0.8;
        }
        .color-btn.selected {
            box-shadow: 0 0 0 3px #fff inset;
        }
        .color-btn .command-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 9px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 2px #fff, 0 0 2px #fff;
            pointer-events: none;
            white-space: nowrap;
        }
        .eyedropper-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .eyedropper-btn:hover {
            background: #555;
        }
        .eyedropper-btn.active {
            background: #0aa;
            border-color: #0ff;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }
        .grid-controls {
            position: absolute;
        }
        .grid-controls.top {
            top: 50%;
            transform: translateY(-50%);
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .grid-controls.bottom {
            top: 50%;
            transform: translateY(-50%);
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .grid-controls.left {
            left: 50%;
            transform: translateX(-50%);
            top: 20px;
            display: flex;
            gap: 5px;
        }
        .grid-controls.right {
            left: 50%;
            transform: translateX(-50%);
            bottom: 20px;
            display: flex;
            gap: 5px;
        }
        .grid-btn {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .grid-btn:hover {
            background: #555;
        }
        canvas {
            border: 2px solid #3e3e42;
            background: white;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .bottom-panel {
            background: #252526;
            border-top: 1px solid #3e3e42;
            height: 200px;
            display: flex;
            overflow: hidden;
        }
        .panel-section {
            flex: 1;
            padding: 15px;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .panel-section:last-child {
            border-right: none;
        }
        .variables-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 10px;
        }
        .variable-item {
            flex: 1;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 4px;
        }
        .variable-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .btn-download {
            background: #444;
            color: white;
            margin-left: auto;
        }
        .btn-download:hover {
            background: #555;
        }
        .panel-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        .panel-content {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #ddd;
            white-space: pre-wrap;
        }
        .stdin-input {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            color: #ddd;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            padding: 10px;
            resize: none;
        }
        .stdin-input:focus {
            outline: none;
            border-color: #0e639c;
        }
        .current-cell {
            box-shadow: 0 0 0 3px #ff0 inset !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="btn btn-run" onclick="run()">‚ñ∂ ÂÆüË°å</button>
        <button class="btn btn-step" onclick="step()">‚èØ „Çπ„ÉÜ„ÉÉ„ÉóÂÆüË°å</button>
        <span style="margin-left: 20px; color: #888;">Grid: <span id="gridSize">10√ó10</span></span>
        <button class="btn btn-download" onclick="copyPPM()">üìã PPM„Ç≥„Éî„Éº</button>
    </div>

    <div class="main-container">
        <div class="color-palette">
            <div class="palette-title">„Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà</div>
            <div class="color-grid" id="colorPalette"></div>
            <div class="color-grid-special" id="colorPaletteSpecial"></div>
            <button class="eyedropper-btn" id="eyedropperBtn" onclick="toggleEyedropper()">
                üé® „Çπ„Éù„Ç§„Éà
            </button>
        </div>

        <div class="canvas-container">
            <div class="grid-controls top">
                <button class="grid-btn" onclick="addRow('top')">+ Ë°å</button>
                <button class="grid-btn" onclick="removeRow('top')">- Ë°å</button>
            </div>
            <div class="grid-controls left">
                <button class="grid-btn" onclick="addColumn('left')">+ Âàó</button>
                <button class="grid-btn" onclick="removeColumn('left')">- Âàó</button>
            </div>
            
            <canvas id="canvas"></canvas>
            
            <div class="grid-controls right">
                <button class="grid-btn" onclick="addColumn('right')">+ Âàó</button>
                <button class="grid-btn" onclick="removeColumn('right')">- Âàó</button>
            </div>
            <div class="grid-controls bottom">
                <button class="grid-btn" onclick="addRow('bottom')">+ Ë°å</button>
                <button class="grid-btn" onclick="removeRow('bottom')">- Ë°å</button>
            </div>
        </div>
    </div>

    <div class="bottom-panel">
        <div class="panel-section">
            <div class="panel-title">Ê®ôÊ∫ñÂÖ•Âäõ</div>
            <textarea class="stdin-input" id="stdin" placeholder="ÂÖ•Âäõ„Éá„Éº„Çø„ÇíÂÖ•Âäõ..."></textarea>
        </div>
        <div class="panel-section">
            <div class="panel-title">Ê®ôÊ∫ñÂá∫Âäõ</div>
            <div class="panel-content" id="stdout">-</div>
        </div>
        <div class="panel-section">
            <div class="panel-title">„Çπ„Çø„ÉÉ„ÇØ</div>
            <div class="panel-content" id="stack">[]</div>
        </div>
        <div class="panel-section">
            <div class="panel-title">Â§âÊï∞</div>
            <div class="variables-container">
                <div class="variable-item">
                    <div class="variable-label">DP</div>
                    <div class="panel-content" id="dp">right (0)</div>
                </div>
                <div class="variable-item">
                    <div class="variable-label">CC</div>
                    <div class="panel-content" id="cc">left (0)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const PIET_COLORS = [
            // Light hues (row 1)
            { name: 'light red', color: '#FFC0C0' },
            { name: 'light yellow', color: '#FFFFC0' },
            { name: 'light green', color: '#C0FFC0' },
            { name: 'light cyan', color: '#C0FFFF' },
            { name: 'light blue', color: '#C0C0FF' },
            { name: 'light magenta', color: '#FFC0FF' },
            // Normal hues (row 2)
            { name: 'red', color: '#FF0000' },
            { name: 'yellow', color: '#FFFF00' },
            { name: 'green', color: '#00FF00' },
            { name: 'cyan', color: '#00FFFF' },
            { name: 'blue', color: '#0000FF' },
            { name: 'magenta', color: '#FF00FF' },
            // Dark hues (row 3)
            { name: 'dark red', color: '#C00000' },
            { name: 'dark yellow', color: '#C0C000' },
            { name: 'dark green', color: '#00C000' },
            { name: 'dark cyan', color: '#00C0C0' },
            { name: 'dark blue', color: '#0000C0' },
            { name: 'dark magenta', color: '#C000C0' },
            // Special
            { name: 'white', color: '#FFFFFF' },
            { name: 'black', color: '#000000' }
        ];

        let gridWidth = 10;
        let gridHeight = 10;
        let cellSize = 30;
        let grid = [];
        let selectedColor = '#FFFFFF';
        let selectedColorIndex = 18; // white
        let currentCell = null;
        let eyedropperMode = false;
        let isRunning = false;
        let isStepMode = false;

        // Interpreter state
        let stack = [];
        let dp = 0; // 0=right, 1=down, 2=left, 3=up
        let cc = 0; // 0=left, 1=right
        let currentPos = null;
        let previousBlockSize = 0;
        let baseColor = null;
        let stepCount = 0;
        let outputBuffer = '';

        // Piet commands based on hue change and lightness change
        const PIET_COMMANDS = [
            ['‚Äî', 'push', 'pop'],
            ['add', 'sub', 'mul'],
            ['div', 'mod', 'not'],
            ['gtr', 'ptr', 'swi'],
            ['dup', 'roll', 'inn'],
            ['inc', 'out', 'ouc']
        ];

        const DP_NAMES = ['right', 'down', 'left', 'up'];
        const CC_NAMES = ['left', 'right'];

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function initGrid() {
            grid = [];
            for (let y = 0; y < gridHeight; y++) {
                grid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    grid[y][x] = '#FFFFFF';
                }
            }
            updateCanvas();
        }

        function updateCanvas() {
            canvas.width = gridWidth * cellSize;
            canvas.height = gridHeight * cellSize;
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    ctx.fillStyle = grid[y][x];
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            if (currentCell) {
                const [cx, cy] = currentCell;
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 3;
                ctx.strokeRect(cx * cellSize, cy * cellSize, cellSize, cellSize);
            }

            document.getElementById('gridSize').textContent = `${gridWidth}√ó${gridHeight}`;
        }

        function updateDebugDisplay() {
            document.getElementById('stack').textContent = JSON.stringify(stack);
            document.getElementById('dp').textContent = `${DP_NAMES[dp]} (${dp})`;
            document.getElementById('cc').textContent = `${CC_NAMES[cc]} (${cc})`;
            document.getElementById('stdout').textContent = outputBuffer || '-';
        }

        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            const paletteSpecial = document.getElementById('colorPaletteSpecial');
            
            // 18Ëâ≤„ÇíÊ®™3ÂàóÔºàÊøÉÂ∫¶Ôºâ√óÁ∏¶6Ë°åÔºàËâ≤Áõ∏Ôºâ„ÅßÈÖçÁΩÆ
            const colorOrder = [
                0, 6, 12,   // light red, red, dark red
                1, 7, 13,   // light yellow, yellow, dark yellow
                2, 8, 14,   // light green, green, dark green
                3, 9, 15,   // light cyan, cyan, dark cyan
                4, 10, 16,  // light blue, blue, dark blue
                5, 11, 17   // light magenta, magenta, dark magenta
            ];
            
            colorOrder.forEach(i => {
                const c = PIET_COLORS[i];
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.style.background = c.color;
                btn.title = c.name;
                btn.onclick = () => selectColor(c.color, btn);
                palette.appendChild(btn);
            });
            
            // ÁôΩ„Å®Èªí
            for (let i = 18; i < 20; i++) {
                const c = PIET_COLORS[i];
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.style.background = c.color;
                btn.title = c.name;
                btn.onclick = () => selectColor(c.color, btn);
                if (i === 18) { // white
                    btn.classList.add('selected');
                }
                paletteSpecial.appendChild(btn);
            }
            
            // Initial command display (none for white)
            updateCommandDisplay();
        }

        function selectColor(color, btn) {
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            selectedColor = color;
            
            // Find color index
            for (let i = 0; i < PIET_COLORS.length; i++) {
                if (PIET_COLORS[i].color === color) {
                    selectedColorIndex = i;
                    break;
                }
            }
            
            eyedropperMode = false;
            document.getElementById('eyedropperBtn').classList.remove('active');
            updateCommandDisplay();
        }

        function updateCommandDisplay() {
            const colorBtns = document.querySelectorAll('#colorPalette .color-btn');
            
            // Clear all command texts
            colorBtns.forEach(btn => {
                const existingText = btn.querySelector('.command-text');
                if (existingText) {
                    existingText.remove();
                }
            });
            
            // If white or black is selected, don't show commands
            if (selectedColorIndex >= 18) {
                return;
            }
            
            // Calculate hue and lightness of selected color
            const selectedHue = selectedColorIndex % 6;
            const selectedLightness = Math.floor(selectedColorIndex / 6);
            
            // Display commands for each color
            const colorOrder = [
                0, 6, 12,   // red colors
                1, 7, 13,   // yellow colors
                2, 8, 14,   // green colors
                3, 9, 15,   // cyan colors
                4, 10, 16,  // blue colors
                5, 11, 17   // magenta colors
            ];
            
            colorOrder.forEach((colorIdx, btnIdx) => {
                const targetHue = colorIdx % 6;
                const targetLightness = Math.floor(colorIdx / 6);
                
                const hueChange = (targetHue - selectedHue + 6) % 6;
                const lightnessChange = (targetLightness - selectedLightness + 3) % 3;
                
                const command = PIET_COMMANDS[hueChange][lightnessChange];
                
                const btn = colorBtns[btnIdx];
                const commandText = document.createElement('span');
                commandText.className = 'command-text';
                commandText.textContent = command;
                btn.appendChild(commandText);
            });
        }

        function toggleEyedropper() {
            eyedropperMode = !eyedropperMode;
            const btn = document.getElementById('eyedropperBtn');
            if (eyedropperMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);

            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                if (eyedropperMode) {
                    selectedColor = grid[y][x];
                    const colorBtns = document.querySelectorAll('.color-btn');
                    colorBtns.forEach((btn, i) => {
                        btn.classList.remove('selected');
                        if (PIET_COLORS[i].color === selectedColor) {
                            btn.classList.add('selected');
                            selectedColorIndex = i;
                        }
                    });
                    eyedropperMode = false;
                    document.getElementById('eyedropperBtn').classList.remove('active');
                    updateCommandDisplay();
                } else {
                    grid[y][x] = selectedColor;
                    updateCanvas();
                }
            }
        });

        function addRow(position) {
            const newRow = new Array(gridWidth).fill('#FFFFFF');
            if (position === 'top') {
                grid.unshift(newRow);
            } else {
                grid.push(newRow);
            }
            gridHeight++;
            updateCanvas();
        }

        function removeRow(position) {
            if (gridHeight <= 1) return;
            if (position === 'top') {
                grid.shift();
            } else {
                grid.pop();
            }
            gridHeight--;
            updateCanvas();
        }

        function addColumn(position) {
            for (let y = 0; y < gridHeight; y++) {
                if (position === 'left') {
                    grid[y].unshift('#FFFFFF');
                } else {
                    grid[y].push('#FFFFFF');
                }
            }
            gridWidth++;
            updateCanvas();
        }

        function removeColumn(position) {
            if (gridWidth <= 1) return;
            for (let y = 0; y < gridHeight; y++) {
                if (position === 'left') {
                    grid[y].shift();
                } else {
                    grid[y].pop();
                }
            }
            gridWidth--;
            updateCanvas();
        }

        function run() {
            resetInterpreter();
            isRunning = true;
            isStepMode = false;
            runLoop();
        }

        function step() {
            if (!isRunning) {
                resetInterpreter();
                isRunning = true;
            }
            isStepMode = true;
            executeStep();
        }

        function resetInterpreter() {
            stack = [];
            dp = 0;
            cc = 0;
            currentPos = [0, 0];
            previousBlockSize = 0;
            baseColor = grid[0][0];
            stepCount = 0;
            outputBuffer = '';
            currentCell = [0, 0];
            updateCanvas();
            updateDebugDisplay();
        }

        function runLoop() {
            if (!isRunning) return;
            
            const result = executeStep();
            
            if (result === 'continue') {
                setTimeout(runLoop, 50);
            } else {
                isRunning = false;
                currentCell = null;
                updateCanvas();
                if (result === 'timeout') {
                    alert('ÂÆüË°å„Åå1000000„Çπ„ÉÜ„ÉÉ„Éó„ÇíË∂Ö„Åà„Åü„Åü„ÇÅÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
                }
            }
        }

        function executeStep() {
            if (stepCount >= 1000000) {
                return 'timeout';
            }
            stepCount++;

            const [x, y] = currentPos;
            const currentColor = grid[y][x];
            
            // Get current color block
            const currentBlock = getColorBlock(x, y, currentColor);
            
            // Find edge position based on DP and CC
            const edgePos = findEdge(currentBlock, dp, cc);
            
            // Try to move
            const nextPos = tryMove(edgePos);
            
            if (!nextPos) {
                return 'halt';
            }
            
            const [nx, ny] = nextPos;
            const nextColor = grid[ny][nx];
            
            // Update position
            currentPos = nextPos;
            currentCell = nextPos;
            updateCanvas();
            
            // Execute command if transitioning from non-white to non-white
            if (currentColor !== '#FFFFFF' && nextColor !== '#FFFFFF' && 
                currentColor !== '#000000' && nextColor !== '#000000') {
                executeCommand(currentColor, nextColor);
                baseColor = nextColor;
            } else if (nextColor !== '#FFFFFF' && nextColor !== '#000000') {
                baseColor = nextColor;
            }
            
            // Update previous block size
            previousBlockSize = currentBlock.size;
            
            updateDebugDisplay();
            
            return isStepMode ? 'halt' : 'continue';
        }

        function getColorBlock(startX, startY, color) {
            const visited = new Set();
            const queue = [[startX, startY]];
            const cells = [];
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) continue;
                if (grid[y][x] !== color) continue;
                
                visited.add(key);
                cells.push([x, y]);
                
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return { cells, size: cells.length };
        }

        function findEdge(block, direction, chooser) {
            const cells = block.cells;
            
            // Find edge based on DP direction
            let edgeCells;
            if (direction === 0) { // right
                const maxX = Math.max(...cells.map(c => c[0]));
                edgeCells = cells.filter(c => c[0] === maxX);
                edgeCells.sort((a, b) => chooser === 0 ? a[1] - b[1] : b[1] - a[1]);
            } else if (direction === 1) { // down
                const maxY = Math.max(...cells.map(c => c[1]));
                edgeCells = cells.filter(c => c[1] === maxY);
                edgeCells.sort((a, b) => chooser === 0 ? b[0] - a[0] : a[0] - b[0]);
            } else if (direction === 2) { // left
                const minX = Math.min(...cells.map(c => c[0]));
                edgeCells = cells.filter(c => c[0] === minX);
                edgeCells.sort((a, b) => chooser === 0 ? b[1] - a[1] : a[1] - b[1]);
            } else { // up
                const minY = Math.min(...cells.map(c => c[1]));
                edgeCells = cells.filter(c => c[1] === minY);
                edgeCells.sort((a, b) => chooser === 0 ? a[0] - b[0] : b[0] - a[0]);
            }
            
            return edgeCells[0];
        }

        function tryMove(fromPos) {
            const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
            let currentDp = dp;
            let currentCc = cc;
            
            // Try up to 4 DP rotations
            for (let rotations = 0; rotations < 4; rotations++) {
                // Try up to 2 CC flips
                for (let ccFlips = 0; ccFlips < 2; ccFlips++) {
                    const [dx, dy] = directions[currentDp];
                    let [x, y] = fromPos;
                    x += dx;
                    y += dy;
                    
                    // Check if blocked (out of bounds or black)
                    const isBlocked = (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) || 
                                     (grid[y][x] === '#000000');
                    
                    if (isBlocked) {
                        // Flip CC and try again
                        currentCc = 1 - currentCc;
                        continue;
                    }
                    
                    const color = grid[y][x];
                    
                    // White - slide through
                    if (color === '#FFFFFF') {
                        const whiteVisited = new Set();
                        let wx = x, wy = y;
                        
                        while (true) {
                            const wkey = `${wx},${wy}`;
                            if (whiteVisited.has(wkey)) {
                                // White loop detected - program terminates
                                return null;
                            }
                            whiteVisited.add(wkey);
                            
                            wx += dx;
                            wy += dy;
                            
                            // Check next cell
                            const nextBlocked = (wx < 0 || wx >= gridWidth || wy < 0 || wy >= gridHeight) ||
                                               (wx >= 0 && wx < gridWidth && wy >= 0 && wy < gridHeight && 
                                                grid[wy][wx] === '#000000');
                            
                            if (nextBlocked) {
                                // Hit wall or black - rotate DP and try again from original position
                                break;
                            }
                            
                            // Check if we exited white
                            if (wx >= 0 && wx < gridWidth && wy >= 0 && wy < gridHeight && 
                                grid[wy][wx] !== '#FFFFFF') {
                                // Successfully exited white into a color block
                                dp = currentDp;
                                cc = currentCc;
                                return [wx, wy];
                            }
                        }
                        
                        // White path blocked - flip CC and try again
                        currentCc = 1 - currentCc;
                        continue;
                    }
                    
                    // Valid move to color block
                    dp = currentDp;
                    cc = currentCc;
                    return [x, y];
                }
                
                // Both CC flips failed - rotate DP
                currentDp = (currentDp + 1) % 4;
                // Reset CC to current value after DP rotation
                currentCc = cc;
            }
            
            // All attempts failed
            return null;
        }

        function executeCommand(fromColor, toColor) {
            const fromIdx = PIET_COLORS.findIndex(c => c.color === fromColor);
            const toIdx = PIET_COLORS.findIndex(c => c.color === toColor);
            
            if (fromIdx < 0 || fromIdx >= 18 || toIdx < 0 || toIdx >= 18) return;
            
            const fromHue = fromIdx % 6;
            const fromLight = Math.floor(fromIdx / 6);
            const toHue = toIdx % 6;
            const toLight = Math.floor(toIdx / 6);
            
            const hueChange = (toHue - fromHue + 6) % 6;
            const lightChange = (toLight - fromLight + 3) % 3;
            
            const command = PIET_COMMANDS[hueChange][lightChange];
            
            executeCommandByName(command);
        }

        function executeCommandByName(cmd) {
            const inputText = document.getElementById('stdin').value;
            
            switch(cmd) {
                case '‚Äî': break;
                case 'push':
                    stack.push(previousBlockSize);
                    break;
                case 'pop':
                    if (stack.length > 0) stack.pop();
                    break;
                case 'add':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a + b);
                    }
                    break;
                case 'sub':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a - b);
                    }
                    break;
                case 'mul':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a * b);
                    }
                    break;
                case 'div':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        if (b !== 0) stack.push(Math.floor(a / b));
                        else stack.push(0);
                    }
                    break;
                case 'mod':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        if (b !== 0) stack.push(a % b);
                        else stack.push(0);
                    }
                    break;
                case 'not':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        stack.push(a === 0 ? 1 : 0);
                    }
                    break;
                case 'gtr':
                    if (stack.length >= 2) {
                        const b = stack.pop();
                        const a = stack.pop();
                        stack.push(a > b ? 1 : 0);
                    }
                    break;
                case 'ptr':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        dp = ((dp + a) % 4 + 4) % 4;
                    }
                    break;
                case 'swi':
                    if (stack.length >= 1) {
                        const a = stack.pop();
                        if (Math.abs(a) % 2 === 1) {
                            cc = 1 - cc;
                        }
                    }
                    break;
                case 'dup':
                    if (stack.length >= 1) {
                        const a = stack[stack.length - 1];
                        stack.push(a);
                    }
                    break;
                case 'roll':
                    if (stack.length >= 2) {
                        const rolls = stack.pop();
                        const depth = stack.pop();
                        if (depth > 0 && depth <= stack.length) {
                            const top = stack.splice(stack.length - depth);
                            const normalizedRolls = ((rolls % depth) + depth) % depth;
                            for (let i = 0; i < normalizedRolls; i++) {
                                top.unshift(top.pop());
                            }
                            stack.push(...top);
                        }
                    }
                    break;
                case 'inn':
                    const num = parseInt(inputText);
                    if (!isNaN(num)) {
                        stack.push(num);
                    }
                    break;
                case 'inc':
                    if (inputText.length > 0) {
                        stack.push(inputText.charCodeAt(0));
                    }
                    break;
                case 'out':
                    if (stack.length >= 1) {
                        const val = stack.pop();
                        outputBuffer += val;
                    }
                    break;
                case 'ouc':
                    if (stack.length >= 1) {
                        const val = stack.pop();
                        outputBuffer += String.fromCharCode(val);
                    }
                    break;
            }
        }

        function copyPPM() {
            let ppm = `P3\n${gridWidth} ${gridHeight}\n255\n`;
            
            for (let y = 0; y < gridHeight; y++) {
                const row = [];
                for (let x = 0; x < gridWidth; x++) {
                    const color = grid[y][x];
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    row.push(`${r} ${g} ${b}`);
                }
                ppm += row.join(' ') + '\n';
            }
            
            navigator.clipboard.writeText(ppm).then(() => {
                alert('PPMÂΩ¢Âºè„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
            }).catch(err => {
                alert('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err);
            });
        }

        initColorPalette();
        initGrid();
    </script>
</body>
</html>